(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{477:function(s,t,n){"use strict";n.r(t);var e=n(10),a=Object(e.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("在 c++ 的引用规则中，有这么一条："),n("strong",[s._v("一旦初始化完成 ，引用将和它的初始值对象一直绑定在一起（即不能再指向其他对象）")]),s._v("。抱着初学者的好奇心态，我尝试改变引用的指向，写出了如下代码：")]),s._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('// 定义两个 string 变量\nstd::string s = "123";\nstd::string s2 = "456";\n\n// 让 s1 引用 s\nstd::string &s1 = s;\nstd::cout << "修改前：" << "s1: " << s1 << std::endl;\n// 修改 s1 的引用？\ns1 = s2;  \nstd::cout << "修改后：" << "s1: " << s1 << std::endl;\n\n// output\n修改前：s1: 123\n修改后：s1: 456\n\n')])])]),n("p",[s._v("这里我让 s1 重新指向 s2，并且从输出结果来看，s1 的值也确实被修改了，不对啊，规则中明明说好了不能修改的，怎么实际代码中可以？为了验证引用是否真的被修改，将三个变量的指针打印出来：")]),s._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('printf("指针 => s1: %p | s2: %p | s: %p \\n", &s1, &s2, &s);\n\n// output\n指针 => s1: 0x7ffee199e7c8 | s2: 0x7ffee199e7b0 | s: 0x7ffee199e7c8 \n')])])]),n("p",[s._v("s1 和 s3 是同一个地址，说明引用并未改变，所以并不是引用被修改了，而是我的理解出现了问题，代码中的 s1 = s2，并不是让引用重新指向 s2，而是把值赋给了与引用绑定的对象（等同于 s = s2），这里做一个简单验证就很好理解了：")]),s._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('// 定义两个 string 变量\nstd::string s = "123";\nstd::string s2 = "456";\n\n// 让 s1 引用 s\nstd::string &s1 = s;\nstd::cout << "修改前：" << "s1: " << s1 << std::endl;\n// 修改 s1 的引用？\ns1 = s2;  \n// 修改 s2 的值，如果 s1 的引用被修改为指向 s2，那么 s1 的值应该也会改为 "666"\ns2 = "666";\nstd::cout << "修改后：" << "s1: " << s1 << std::endl;\n\n\n// output\n修改前：s1: 123\n修改后：s1: 456\n')])])]),n("p",[s._v('s1 并没有被修改为 "666"，所以可以印证上面的说法。')]),s._v(" "),n("Vssue",{attrs:{title:s.$title}})],1)}),[],!1,null,null,null);t.default=a.exports}}]);